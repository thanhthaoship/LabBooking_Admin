# Senior Next.js Frontend Development Rules

## Tech Stack
- **Framework**: Next.js 14+ (App Router)
- **UI Library**: shadcn/ui components
- **Styling**: Tailwind CSS
- **Data Fetching**: TanStack Query (React Query) v5
- **Design System**: shadcn/ui default styling

## Code Style & Standards

### General Principles
- Write clean, maintainable TypeScript code
- Use functional components with hooks
- Prefer composition over inheritance
- Keep components small and focused (single responsibility)
- Use explicit typing, avoid `any` types
- Write self-documenting code with clear variable names

### File Structure
```
src/
├── app/                    # Next.js app router pages
├── components/
│   ├── ui/                # shadcn/ui components
│   └── layouts/           # Layout components
├── lib/
│   ├── hooks/             # Custom hooks
│   └── utils/             # Utility functions
├── servies/               # API client functions
    └── api/               # API client functions
└── styles/                # Global styles
```

## shadcn/ui Guidelines

### Component Usage
- Always use shadcn/ui components as the foundation
- Install components via CLI: `npx shadcn@latest add [component]`
- Customize components in `components/ui/` for project-specific needs
- Never modify components directly from node_modules

### Component Patterns
```typescript
// Import shadcn components
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"

// Extend with custom variants when needed
import { cn } from "@/lib/utils"

// Example custom component
export function FeatureCard({ className, ...props }: ComponentProps) {
  return (
    <Card className={cn("custom-styles", className)} {...props}>
      {/* content */}
    </Card>
  )
}
```

### Form Handling
- Use `react-hook-form` with shadcn Form components
- Implement Zod for schema validation
- Always show proper error states

```typescript
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { Form, FormField, FormItem, FormLabel } from "@/components/ui/form"

const formSchema = z.object({
  email: z.string().email(),
})

// Use in component with proper typing
const form = useForm<z.infer<typeof formSchema>>({
  resolver: zodResolver(formSchema),
})
```

## TanStack Query (React Query) Best Practices

### Setup
- Configure QueryClient in app layout with proper defaults
- Use optimal staleTime and cacheTime settings
- Enable devtools in development

```typescript
// app/providers.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000, // 1 minute
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
})
```

### Query Patterns
```typescript
// lib/api/users.ts - API functions
export async function getUsers() {
  const res = await fetch('/api/users')
  if (!res.ok) throw new Error('Failed to fetch users')
  return res.json()
}

// lib/hooks/useUsers.ts - Custom hook
import { useQuery } from '@tanstack/react-query'

export function useUsers() {
  return useQuery({
    queryKey: ['users'],
    queryFn: getUsers,
  })
}

// components/UserList.tsx - Component usage
export function UserList() {
  const { data, isLoading, error } = useUsers()
  
  if (isLoading) return <Skeleton />
  if (error) return <ErrorAlert error={error} />
  
  return <div>{/* render users */}</div>
}
```

### Mutation Patterns
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'

export function useCreateUser() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['users'] })
    },
    onError: (error) => {
      // Handle error (toast notification, etc.)
    },
  })
}
```

### Query Key Management
- Use consistent, hierarchical query keys
- Create query key factories for complex queries

```typescript
// lib/api/queryKeys.ts
export const queryKeys = {
  users: {
    all: ['users'] as const,
    lists: () => [...queryKeys.users.all, 'list'] as const,
    list: (filters: string) => [...queryKeys.users.lists(), filters] as const,
    details: () => [...queryKeys.users.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.users.details(), id] as const,
  },
}
```

## shadcn/ui Design Guidelines

### Core Design Principles
- Use shadcn/ui default theme and variants
- Maintain consistent spacing and sizing
- Follow shadcn/ui design tokens for colors and typography
- Leverage built-in component variants (default, destructive, outline, etc.)
- Customize theme via `tailwind.config.ts` when needed

### Tailwind Configuration
```typescript
// tailwind.config.ts - Extend shadcn theme
export default {
  theme: {
    extend: {
      // Add custom values while maintaining shadcn defaults
      colors: {
        // shadcn uses CSS variables, extend if needed
      },
    },
  },
}
```

### Component Styling Patterns
```typescript
// Use built-in shadcn variants
<Button variant="default">Primary Action</Button>
<Button variant="outline">Secondary Action</Button>
<Button variant="ghost">Tertiary Action</Button>

// Combine with Tailwind utilities
<Card className="max-w-md">
  <CardHeader>
    <CardTitle>Title</CardTitle>
    <CardDescription>Description text</CardDescription>
  </CardHeader>
  <CardContent>{/* content */}</CardContent>
  <CardFooter>{/* footer */}</CardFooter>
</Card>

// Responsive and state-based styling
<Input 
  className="focus-visible:ring-2" 
  placeholder="Enter text..."
/>
```

### Design Tokens
```css
/* Use shadcn's CSS variables for consistency */
.custom-component {
  background: hsl(var(--background));
  color: hsl(var(--foreground));
  border: 1px solid hsl(var(--border));
  border-radius: var(--radius);

}
```

## Next.js Specific Rules

### App Router
- Use Server Components by default
- Add 'use client' only when necessary (hooks, event handlers, browser APIs)
- Leverage Server Actions for mutations when appropriate
- Use proper loading and error boundaries

### Data Fetching Strategy
- Server Components: Direct database/API calls
- Client Components: TanStack Query for interactive data
- Use `loading.tsx` for loading states
- Use `error.tsx` for error boundaries

### Performance
- Implement proper image optimization with next/image
- Use dynamic imports for code splitting
- Implement proper caching strategies
- Minimize 'use client' boundaries

## TypeScript Standards

### Type Definitions
```typescript
// Always define proper types
interface User {
  id: string
  name: string
  email: string
}

// Use type for API responses
type ApiResponse<T> = {
  data: T
  error?: string
}

// Generic component props
interface ComponentProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'accent'
}
```

## Best Practices

### Error Handling
- Always handle loading and error states in queries
- Show user-friendly error messages
- Use toast notifications for mutations
- Implement proper error boundaries

### Accessibility
- Use semantic HTML elements
- Ensure keyboard navigation works
- Add proper ARIA labels where needed
- Test with screen readers
- Maintain proper color contrast ratios (WCAG AA minimum)

### Performance Optimization
- Implement proper loading skeletons
- Use optimistic updates for better UX
- Leverage React Query's caching
- Minimize unnecessary re-renders

### Testing Considerations
- Write component tests for critical features
- Test custom hooks in isolation
- Mock TanStack Query in tests
- Test accessibility requirements

## Common Patterns

### Page Component Pattern
```typescript
// app/users/page.tsx
import { UserList } from '@/components/features/users/UserList'
import { Suspense } from 'react'
import { UserListSkeleton } from '@/components/features/users/UserListSkeleton'

export default function UsersPage() {
  return (
    <div className="container py-8">
      <h1 className="text-3xl font-bold mb-8">Users</h1>
      <Suspense fallback={<UserListSkeleton />}>
        <UserList />
      </Suspense>
    </div>
  )
}
```

### Feature Component Pattern
```typescript
// components/features/users/UserList.tsx
'use client'

import { useUsers } from '@/lib/hooks/useUsers'
import { Card } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'

export function UserList() {
  const { data: users, isLoading, error } = useUsers()
  
  if (isLoading) return <UserListSkeleton />
  if (error) return <ErrorState error={error} />
  
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {users?.map(user => (
        <Card key={user.id} className="hover:shadow-lg transition-shadow">
          {/* content */}
        </Card>
      ))}
    </div>
  )
}
```

## Code Review Checklist
- [ ] TypeScript types are properly defined
- [ ] Components are properly sized and focused
- [ ] TanStack Query is used correctly with proper keys
- [ ] Loading and error states are handled
- [ ] shadcn/ui components are used consistently
- [ ] Accessibility requirements are met
- [ ] Performance is optimized
- [ ] Code is properly formatted and linted